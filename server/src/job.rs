use crate::{
    formatter::{to_html_build_result, to_markdown_build_result},
    github::{AMD64, ARM64, LOONGSON3, MIPS64R6EL, NOARCH, PPC64EL, RISCV64},
    ALL_ARCH, ARGS,
};
use anyhow::{anyhow, bail};
use common::{JobError, JobOk, JobResult};
use futures::StreamExt;
use lapin::{
    options::{BasicAckOptions, BasicConsumeOptions, QueueDeclareOptions},
    types::FieldTable,
    Channel, ConnectionProperties,
};
use log::{error, info, warn};
use std::time::Duration;
use teloxide::{prelude::*, types::ParseMode};

/// All arch queue
pub async fn all_arch_queue(channel: &Channel) -> anyhow::Result<Vec<String>> {
    let mut res = vec![];
    for i in ALL_ARCH {
        let queue = channel
            .basic_consume(
                &format!("job-{i}"),
                "",
                BasicConsumeOptions::default(),
                FieldTable::default(),
            )
            .await;

        let mut cons = queue?;

        while let Some(de) = cons.next().await {
            match de {
                Ok(d) => res.push(String::from_utf8_lossy(&d.data).to_string()),
                Err(e) => {
                    error!("{e}");
                    continue;
                }
            }
        }
    }

    Ok(res)
}

/// Observe job completion messages
pub async fn job_completion_worker_inner(bot: Bot, amqp_addr: &str) -> anyhow::Result<()> {
    let conn = lapin::Connection::connect(amqp_addr, ConnectionProperties::default()).await?;

    let channel = conn.create_channel().await?;
    let _queue = channel
        .queue_declare(
            "job-completion",
            QueueDeclareOptions {
                durable: true,
                ..QueueDeclareOptions::default()
            },
            FieldTable::default(),
        )
        .await?;

    let mut consumer = channel
        .basic_consume(
            "job-completion",
            "backend_server",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await?;

    while let Some(delivery) = consumer.next().await {
        let delivery = match delivery {
            Ok(delivery) => delivery,
            Err(err) => {
                error!("Got error in lapin delivery: {}", err);
                continue;
            }
        };

        match serde_json::from_slice::<JobResult>(&delivery.data) {
            Ok(result) => {
                match result {
                    JobResult::Ok(job) => {
                        info!("Processing job result {:?} ...", job);

                        let JobOk {
                            job: job_parent,
                            successful_packages,
                            ..
                        } = &job;

                        let success = job_parent
                            .packages
                            .iter()
                            .all(|x| successful_packages.contains(x));

                        let s = to_html_build_result(&job, success);

                        bot.send_message(job.job.tg_chatid, &s)
                            .parse_mode(ParseMode::Html)
                            .disable_web_page_preview(true)
                            .await?;

                        // if associated with github pr, update comments
                        if let Some(github_access_token) = &ARGS.github_access_token {
                            if let Some(pr) = job_parent.github_pr {
                                let new_content = to_markdown_build_result(&job, success);

                                // update or create new comment
                                let page = octocrab::instance()
                                    .issues("AOSC-Dev", "aosc-os-abbs")
                                    .list_comments(pr)
                                    .send()
                                    .await?;

                                let crab = octocrab::Octocrab::builder()
                                    .user_access_token(github_access_token.clone())
                                    .build()?;

                                // TODO: handle paging
                                let mut found = false;
                                for comment in page {
                                    // find existing comment generated by @aosc-buildit-bot
                                    if comment.user.login == "aosc-buildit-bot" {
                                        // found, append new data
                                        found = true;
                                        info!("Found existing comment, updating");

                                        let mut body = String::new();
                                        if let Some(orig) = &comment.body {
                                            body += orig;
                                            body += "\n";
                                        }
                                        body += &new_content;

                                        crab.issues("AOSC-Dev", "aosc-os-abbs")
                                            .update_comment(comment.id, body)
                                            .await?;
                                        break;
                                    }
                                }

                                if !found {
                                    info!("No existing comments, create one");
                                    crab.issues("AOSC-Dev", "aosc-os-abbs")
                                        .create_comment(pr, new_content)
                                        .await?;
                                }

                                if success {
                                    let body = crab
                                        .pulls("AOSC-Dev", "aosc-os-abbs")
                                        .get(pr)
                                        .await?
                                        .body
                                        .ok_or_else(|| anyhow!("This PR has no body"))?;

                                    let pr_arch = match job_parent.arch.as_str() {
                                        "amd64" if job_parent.noarch => NOARCH,
                                        "amd64" => AMD64,
                                        "arm64" => ARM64,
                                        "loongson3" => LOONGSON3,
                                        "mips64r6el" => MIPS64R6EL,
                                        "ppc64el" => PPC64EL,
                                        "riscv64" => RISCV64,
                                        _ => bail!("Unknown architecture"),
                                    };

                                    let body = body.replace(
                                        &format!("- [ ] {pr_arch}"),
                                        &format!("- [x] {pr_arch}"),
                                    );

                                    crab.pulls("AOSC-Dev", "aosc-os-abbs")
                                        .update(pr)
                                        .body(body)
                                        .send()
                                        .await?;
                                }
                            }
                        }
                    }
                    JobResult::Error(job) => {
                        let JobError { job, worker, error } = job;
                        bot.send_message(
                            job.tg_chatid,
                            format!(
                                "{}({}) build packages: {:?} Got Error: {}",
                                worker.hostname, job.arch, job.packages, error
                            ),
                        )
                        .await?;
                    }
                }
            }
            Err(err) => {
                warn!("Got invalid json in job-completion: {}", err);
            }
        }

        // finish
        if let Err(err) = delivery.ack(BasicAckOptions::default()).await {
            warn!(
                "Failed to delete job result {:?}, error: {:?}",
                delivery, err
            );
        } else {
            info!("Finished processing job result {:?}", delivery.delivery_tag);
        }
    }
    Ok(())
}

pub async fn job_completion_worker(bot: Bot, amqp_addr: String) -> anyhow::Result<()> {
    loop {
        info!("Starting job completion worker ...");
        if let Err(err) = job_completion_worker_inner(bot.clone(), &amqp_addr).await {
            error!("Got error while starting job completion worker: {}", err);
        }
        tokio::time::sleep(Duration::from_secs(5)).await;
    }
}
